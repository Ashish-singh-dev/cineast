import axios from "axios";
import { OAuth2Client } from "google-auth-library";
import NextAuth, { NextAuthOptions } from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import TwitterProvider from "next-auth/providers/twitter";
import CredentialsProvider from "next-auth/providers/credentials";

import { User } from "@customTypes/User";
import generateNewUserData from "@utils/generateNewUserData";

// This is an instance of a google client that we need to ask google informations about the user
const googleAuthClient = new OAuth2Client(
	process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID
);

export const authOptions: NextAuthOptions = {
	// Configure one or more authentication providers
	providers: [
		GoogleProvider({
			clientId: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID as string,
			clientSecret: process.env.GOOGLE_CLIENT_SECRET as string,
		}),
		TwitterProvider({
			clientId: process.env.TWITTER_CLIENT_ID as string,
			clientSecret: process.env.TWITTER_CLIENT_SECRET as string,
		}),
		CredentialsProvider({
			// The id of this credential provider. It's important to give an id because, in frontend we don't want to
			// show anything about this provider in a normal login flow
			id: "googleonetap",
			// A readable name
			name: "google-one-tap",

			// This field define what parameter we expect from the FE and what's its name. In this case "credential"
			// This field will contain the token generated by google
			credentials: {
				credential: { type: "text" },
			},
			// This is where all the logic goes
			authorize: async (credentials) => {
				if (!credentials) {
					throw new Error("Cannot extract token from credentials");
				}
				// The token given by google and provided from the frontend
				const token = credentials.credential;
				// We use the google library to exchange the token with some information about the user
				const ticket = await googleAuthClient.verifyIdToken({
					// The token received from the interface
					idToken: token,
					// This is the google ID of your application
					audience: process.env.NEXT_PUBLIC_GOOGLE_ID,
				});
				const payload = ticket.getPayload(); // This is the user

				if (!payload) {
					throw new Error("Cannot extract payload from signin token");
				}

				// If the request went well, we received all this info from Google.
				const {
					email,
					sub: id,
					given_name,
					family_name,
					email_verified,
					picture: image,
				} = payload;

				// If for some reason the email is not provided, we cannot login the user with this method
				if (!email) {
					throw new Error("Email not available");
				}
				let name = undefined;
				if (given_name && family_name) {
					name = [given_name, family_name].join(" ");
				} else if (given_name && !family_name) {
					name = given_name;
				}
				return { email, name, image, id };
			},
		}),
	],
	pages: {
		signIn: "/auth/signin",
		error: "/auth/error",
	},
	callbacks: {
		async jwt({ token, user }) {
			if (user) token.id = user.id;
			return token;
		},
		async session({ session, token }) {
			const user = await axios.get<User>(
				`${process.env.NEXT_PUBLIC_BACKEND_URL}/v1/user/by-id/${token.id}`
			);
			if (!user.data?.results?.username) throw new Error("Failed to signin!");
			session.user.id = token.id as string;
			session.user.username = user.data.results.username;
			return session;
		},
		async signIn({ user, account }) {
			try {
				const isUserExists = await axios.get<User>(
					`${process.env.NEXT_PUBLIC_BACKEND_URL}/v1/user/by-id/${user.id}`
				);
				if (isUserExists.data?.results?.id) return true;
				else {
					const userData = generateNewUserData(user, account);
					const res = await axios.post<User>(
						`${process.env.NEXT_PUBLIC_BACKEND_URL}/v1/user/new`,
						userData
					);
					console.log("ðŸš€ ~ file: [...nextauth].ts:113 ~ signIn ~ res", res);
					if (res.data?.results?.id) {
						if (res.data.results.id !== user.id)
							throw new Error("A user with this email is already exist!");
						return true;
					} else throw new Error("Failed to create user!");
				}
			} catch (error) {
				throw new Error(`${error}`);
			}
		},
	},
};

export default NextAuth(authOptions);
